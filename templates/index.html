<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Dictionary</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@11.0.0/dist/handsontable.full.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <style>
        .modal-dialog-fullscreen {
            width: 100%;
            max-width: none;
            height: 100%;
            margin: 0;
        }

        .modal-content-fullscreen {
            height: 100%;
            border: 0;
            border-radius: 0;
        }

        .modal-body-fullscreen {
            overflow-y: auto;
            height: calc(100% - 120px); /* Adjust 120px based on your header and footer height */
        }

        .draggable-source--is-dragging, .draggable-source--placed {
            opacity: 0.5;
        }

        .draggable--original {
            visibility: hidden;
        }

        .drag-hide {
            display: none;
        }

    </style>
</head>
<body>

<div class="container-fluid mt-3">
    <div class="row">
        <div class="col-md-4 col-lg-3">
            <input class="form-control" type="file" id="excelFile" aria-label="Upload Excel File">
        </div>

        <div class="col-md-4 col-lg-3">
            <div class="input-group mb-3">
                <input type="text" class="form-control" placeholder="Enter Sheet Name" aria-label="Sheet Name"
                       id="sheetName">
                <button class="btn btn-outline-secondary" type="button" id="loadData" onclick="loadData()">Load Data
                </button>
            </div>
        </div>

        <div class="col-md-4 col-lg-5">
            <button id="openModalBtn" type="button" class="btn btn-primary" data-bs-toggle="modal"
                    data-bs-target="#myModal">View Data Dictionary
            </button>
            <button id="saveTableBtn" type="button" class="btn btn-primary" onclick="exportToExcel(hotTableViewer)">Save
                Table to Excel
            </button>
        </div>
    </div>
</div>

<div class="container">
    <div class="row">
        <!-- Left half starts -->
        <div class="col-md-6">
            <div class="form-floating mb-3 mt-1">
                <select class="form-select" id="procedureSelect" aria-label="Select Procedure ID:">
                    <option selected>Select Procedure ID</option>
                </select>
                <label for="procedureSelect">Procedure ID:</label>
            </div>

            <div class="input-group mb-3">
                <div class="form-floating">
                    <input type="text" aria-label="Header" id="headerInput" class="form-control">
                    <label for="headerInput">Header:</label>
                </div>
                <div class="form-floating">
                    <input type="text" aria-label="Header" id="deviceInput" class="form-control">
                    <label for="deviceInput">Device:</label>
                </div>
                <button id="addHeaderToTableBtn" class="btn btn-primary ms-2" data-bs-toggle="tooltip"
                        data-bs-placement="top"
                        data-bs-title="Add Header to Table">
                    <i class="fa-solid fa-arrow-right"></i>
                </button>
            </div>

            <div class="input-group mb-3">
                <div class="form-floating">
                    <select class="form-select" aria-label="Subheader" id="subheaderInput" class="form-control">
                        <option selected>Select Subheader</option>
                        <option>Arteries</option>
                        <option>Centers</option>
                        <option>Devices</option>
                        <option>Legs</option>
                        <option>Patients</option>
                        <option>Physicians</option>
                        <option>Procedures</option>
                    </select>
                    <label for="subheaderInput">Subheader:</label>
                </div>
                <div class="form-floating">
                    <select class="form-select" id="subHeaderStatisticsSelect" aria-label="Select Statistic:">
                        <option selected>Count</option>
                        <option>Mean_SD</option>
                        <option>Percentage</option>
                    </select>
                    <label for="subHeaderStatisticsSelect">Select Statistic:</label>
                </div>
                <button id="addSubheaderToTableBtn" class="btn btn-primary ms-2" data-bs-toggle="tooltip"
                        data-bs-placement="top"
                        data-bs-title="Add Subheader to Table">
                    <i class="fa-solid fa-arrow-right"></i>
                </button>
            </div>

            <div class="input-group mb-3">
                <div class="form-floating">
                    <select id="formTabSelect" class="form-select">
                        <option selected>Select Field Grouping</option>
                    </select>
                    <label for="formTabSelect">Field Grouping</label>
                </div>
                <button id="addToTableBtn" class="btn btn-primary ms-2" data-bs-toggle="tooltip" data-bs-placement="top"
                        data-bs-title="Add Field Label(s) to Table">
                    <i class="fa-solid fa-arrow-right"></i>
                </button>

            </div>

            <div class="field-label-group mb-3" id="initial-field-label-group">
                <div class="input-group mb-3">
                    <button class="btn btn-danger remove-field-label-btn me-2" type="button">-</button>
                    <select id="fieldLabelSelect" class="form-select field-label-select">
                        <option selected>Select Field Label</option>
                    </select>
                    <button class="btn btn-primary add-field-label-btn ms-2" type="button">+</button>
                </div>
                <div class="response-options-container dropzone">
                    <!-- Response options will be populated here -->
                </div>
            </div>
        </div>
        <!-- Left half ends -->
        <div class="col-md-6">
            <!-- Container for Handsontable -->
            <div id="hotTableViewerContainer" class="handsontable-container mt-2"></div>
        </div>
        <!-- Right half ends -->
    </div>
</div>


<!-- The Data Dictionary Modal -->
<div class="modal fade" id="myModal" tabindex="-1" aria-labelledby="modalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-fullscreen modal-xl">
        <div class="modal-content modal-content-fullscreen">
            <div class="modal-header">
                <h5 class="modal-title" id="modalLabel">Data Dictionary</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body modal-body-fullscreen">
                <div id="hot"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="exportToExcel(hotDataDictionary)">Export to
                    Excel
                </button>
                <button type="button" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/handsontable@11.0.0/dist/handsontable.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
<script src="https://kit.fontawesome.com/e8883a6e4f.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@shopify/draggable/build/umd/index.min.js"></script>


<script type="module">
    // Import Sortable to sort the response options for the first Response Option container.
    import Sortable from 'https://cdn.jsdelivr.net/npm/@shopify/draggable/build/esm/Sortable/Sortable.mjs';

    const containerSelector = '.dropzone';
    const containers = document.querySelectorAll(containerSelector);

    function initializeSortable() {
        const containers = document.querySelectorAll('.dropzone');
        new Sortable(containers, {
            draggable: '.drag-drop',
            handle: '.drag-handle',
            mirror: {
                appendTo: containerSelector,
                constrainDimensions: true,
            }
        });
    }

    document.addEventListener("DOMContentLoaded", () => {
        initializeSortable();
    });

    // Export this function if needed elsewhere in your script
    window.initializeSortable = initializeSortable;
</script>

<script>
    // Initialize required global variables
    let hotDataDictionary;
    let hotTableViewer;
    let globalUniqueFieldLabels = [];
    let responseOptionsMap = {};

    // Initialize Bootstrap tooltips
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
    const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))

    //Initialize Data Dictionary modal
    document.getElementById('myModal').addEventListener('shown.bs.modal', function () {
        if (!hotDataDictionary) {
            hotDataDictionary = new Handsontable(document.getElementById('hot'), {
                // Handsontable options
            });
        } else {
            hotDataDictionary.render(); // Re-render if already initialized
        }
    });

    // Initialize required event listeners, other functions, and initial states.
    document.addEventListener("DOMContentLoaded", function () {

        // Check session for a previously entered sheet name.
        const storedSheetName = sessionStorage.getItem('sheetName');
        if (storedSheetName) {
            document.getElementById('sheetName').value = storedSheetName;
        }

        document.getElementById('procedureSelect').addEventListener('change', handleProcedureSelectChange);

        document.getElementById('formTabSelect').addEventListener('change', handleFormTabSelectChange);

        document.querySelector('.add-field-label-btn').addEventListener('click', addFieldLabelSelect);

        const fieldLabelSelectElement = document.getElementById('fieldLabelSelect');
        document.getElementById('fieldLabelSelect').addEventListener('change', fieldLabelSelectChangeHandler);

        document.querySelector('.remove-field-label-btn').style.visibility = 'hidden';

        // Initialize the Table Viewer
        const hotViewerContainer = document.getElementById('hotTableViewerContainer');
        hotTableViewer = new Handsontable(hotViewerContainer, {
            licenseKey: 'non-commercial-and-evaluation',
            colHeaders: false,
            rowHeaders: true,
            manualRowMove: true,
            startCols: 3,
            hiddenColumns: {
                columns: [3, 4, 5],
                indicators: true
            },
            contextMenu: ['row_above', 'row_below', 'remove_row', 'undo', 'redo', 'alignment', 'mergeCells'],
            mergeCells: true
        });

    });

    // Function to populate the Procedure ID from the data dictionary.
    function populateProcedureSelect() {
        const mainData = hotDataDictionary.getData();
        const procedureIndex = hotDataDictionary.getColHeader().indexOf('PROCEDUREID');
        let procedureIDs = [...new Set(mainData.map(row => row[procedureIndex]))];

        // If Procedure IDs are numeric, convert them to numbers for sorting
        procedureIDs = procedureIDs.map(id => isNaN(Number(id)) ? id : Number(id));

        // Sort the procedure IDs
        procedureIDs.sort((a, b) => {
            if (typeof a === 'number' && typeof b === 'number') {
                return a - b; // Sort numerically
            } else {
                return a.toString().localeCompare(b.toString()); // Sort alphabetically
            }
        });

        const procedureSelect = document.getElementById('procedureSelect');
        procedureSelect.innerHTML = '<option selected>Select Procedure ID</option>';
        procedureIDs.forEach(id => {
            const option = document.createElement('option');
            option.value = id;
            option.textContent = id;
            procedureSelect.appendChild(option);
        });
    }

    // Function to populate the Field Grouping/Form Tab from the data dictionary upon selecting a Procedure ID.
    function handleProcedureSelectChange() {
        const selectedProcedureID = this.value.trim();
        const mainData = hotDataDictionary.getData();
        const procedureIndex = hotDataDictionary.getColHeader().indexOf('PROCEDUREID');
        const formTabIndex = hotDataDictionary.getColHeader().indexOf('FORM_TAB');

        // Filter for rows with the selected PROCEDURE ID
        const filteredRows = mainData.filter(row => {
            let rowProcedureID = row[procedureIndex];
            if (rowProcedureID != null) {
                rowProcedureID = String(rowProcedureID).trim();
            }
            return rowProcedureID === selectedProcedureID;
        });

        //console.log("Filtered Rows:", filteredRows); // Debugging

        // Extract unique FORM_TAB values from filtered rows and sort them
        const relatedFormTabs = [...new Set(filteredRows.map(row => row[formTabIndex]))].sort();
        //console.log("Related FORM_TABs:", relatedFormTabs); // Debugging

        // Populate formTabSelect
        const formTabSelect = document.getElementById('formTabSelect');
        formTabSelect.innerHTML = '<option selected>Select Field Grouping</option>';
        relatedFormTabs.forEach(tab => {
            const option = document.createElement('option');
            option.value = tab;
            option.textContent = tab;
            formTabSelect.appendChild(option);
        });

        resetInitialFieldLabelAndOptions();
        removeDynamicallyAddedFields();
    }


    // Function to populate Field Labels from the data dictionary upon selecting a Form Tab.
    function handleFormTabSelectChange() {
        const selectedProcedureID = document.getElementById('procedureSelect').value.trim();
        const selectedFormTab = this.value.trim();
        //console.log("Selected FORM_TAB:", selectedFormTab);

        const mainData = hotDataDictionary.getData();
        const procedureIndex = hotDataDictionary.getColHeader().indexOf('PROCEDUREID');
        const formTabIndex = hotDataDictionary.getColHeader().indexOf('FORM_TAB');
        const fieldLabelIndex = hotDataDictionary.getColHeader().indexOf('FIELD_LABEL');
        const fieldCodeIndex = hotDataDictionary.getColHeader().indexOf('FIELD_CODE');
        const fieldStatusIndex = hotDataDictionary.getColHeader().indexOf('FIELD_STATUS');
        const responseOptionsIndex = hotDataDictionary.getColHeader().indexOf('RESPONSE_OPTIONS');

        const filteredRows = mainData.filter(row => {
            let rowProcedureID = row[procedureIndex];
            let rowFormTab = row[formTabIndex];
            let rowFieldStatus = row[fieldStatusIndex];
            if (rowProcedureID != null) rowProcedureID = String(rowProcedureID).trim();
            if (rowFormTab != null) rowFormTab = String(rowFormTab).trim();
            if (rowFieldStatus != null) rowFieldStatus = String(rowFieldStatus).trim();
            return rowProcedureID === selectedProcedureID && rowFormTab === selectedFormTab && rowFieldStatus === 'ACTIVE';
        });

        //Log the filtered rows for debugging
        //filteredRows.forEach(row => {console.log(row[row.length - 1]););

        let uniqueFieldLabels = [...new Set(filteredRows.map(row => row[fieldLabelIndex]))].sort();
        //console.log("Related FIELD_LABELs:", uniqueFieldLabels);

        let fieldLabelCodeMap = new Map();
        filteredRows.forEach(row => {
            const fieldLabel = row[fieldLabelIndex];
            const fieldCode = row[fieldCodeIndex];
            fieldLabelCodeMap.set(fieldLabel, fieldCode);
        });


        document.querySelectorAll('.field-label-select').forEach(selectElement => {
            populateFieldLabelSelect(selectElement, uniqueFieldLabels, fieldLabelCodeMap);
        });

        filteredRows.forEach(row => {
            const fieldLabel = row[fieldLabelIndex];
            const responseOptions = row[responseOptionsIndex];
            const compositeKey = `${selectedProcedureID}_${selectedFormTab}_${fieldLabel}`;
            if (responseOptions) {
                responseOptionsMap[compositeKey] = responseOptions.match(/(\d+\s*=\s*.*?)(?=\s*,\d+\s*=|$)/g).filter(match => !match.includes('(retired')).sort();
            }
        });

        const selectedLabels = updateSelectedFieldLabels();
        updateFieldLabelOptions(selectedLabels);
        populateInitialResponseOptions();
        resetInitialFieldLabelAndOptions();
        removeDynamicallyAddedFields();
    }

    // Function to reset the initial Field Label and Response Options upon changing the Procedure ID or Form Tab.
    function resetInitialFieldLabelAndOptions() {
        const initialFieldLabelSelect = document.getElementById('fieldLabelSelect');
        initialFieldLabelSelect.value = 'Select Field Label';

        const initialResponseOptionsContainer = document.getElementById('initial-field-label-group').querySelector('.response-options-container');
        if (initialResponseOptionsContainer) {
            initialResponseOptionsContainer.innerHTML = ''; // Clear response options
        }
    }

    // Function to remove dynamically added Field Label and Response Options upon changing the Procedure ID or Form Tab.
    function removeDynamicallyAddedFields() {
        const dynamicallyAddedFieldGroups = document.querySelectorAll('.field-label-group:not(#initial-field-label-group)');
        dynamicallyAddedFieldGroups.forEach(group => group.remove());
    }


    // Function to handle adding new Field Label selectors.
    function addFieldLabelSelect(event) {
        const currentAddButton = event.target;
        if (currentAddButton.nodeName === 'BUTTON' && currentAddButton.parentNode) {
            const currentContainer = currentAddButton.parentNode;
            const newContainer = document.createElement('div');
            newContainer.className = 'input-group mb-3';

            const newFieldLabelSelect = document.createElement('select');
            newFieldLabelSelect.className = 'form-select field-label-select';
            newFieldLabelSelect.innerHTML = currentContainer.querySelector('select').innerHTML;
            newFieldLabelSelect.addEventListener('change', fieldLabelSelectChangeHandler);

            const removeButton = document.createElement('button');
            removeButton.className = 'btn btn-outline-danger';
            removeButton.textContent = '-';
            removeButton.addEventListener('click', removeFieldLabelSelect); // Attach the event listener

            const addButton = document.createElement('button');
            addButton.className = 'btn btn-outline-primary';
            addButton.textContent = '+';
            addButton.onclick = addFieldLabelSelect;

            newContainer.appendChild(removeButton);
            newContainer.appendChild(newFieldLabelSelect);
            newContainer.appendChild(addButton);

            const fieldLabelGroup = document.createElement('div');
            fieldLabelGroup.className = 'field-label-group mb-2';

            // Append input group to field label group
            fieldLabelGroup.appendChild(newContainer);

            // Append response options container to field label group
            const responseOptionsContainer = document.createElement('div');
            responseOptionsContainer.className = 'response-options-container dropzone';
            fieldLabelGroup.appendChild(responseOptionsContainer);

            // Insert the new field label group after the current one
            currentContainer.closest('.field-label-group').after(fieldLabelGroup);


            attachFieldLabelSelectListeners();
        }

        // Update the options for all fieldLabelSelect elements
        const selectedLabels = updateSelectedFieldLabels();
        updateFieldLabelOptions(selectedLabels);
    }

    // Function to handle removing Field Labels selectors upon clicking the remove button.
    function removeFieldLabelSelect(event) {
        const fieldLabelGroup = event.target.closest('.field-label-group');
        if (fieldLabelGroup) {
            fieldLabelGroup.remove();
        } else {
            console.error('Field label group not found for the remove button.');
        }

        // Update the selected field labels if necessary
        const selectedLabels = updateSelectedFieldLabels();
        updateFieldLabelOptions(selectedLabels);
    }


    // Function to populate the Field Label selectors upon selecting a Form Tab.
    function populateFieldLabelSelect(selectElement, uniqueFieldLabels, fieldLabelCodeMap) {
        selectElement.innerHTML = '<option selected>Select Field Label</option>';
        uniqueFieldLabels.forEach(label => {
            const option = document.createElement('option');
            option.value = label;
            option.textContent = label;
            if (fieldLabelCodeMap.has(label)) {
                option.setAttribute('data-field-code', fieldLabelCodeMap.get(label));
            }
            selectElement.appendChild(option);
        });
    }

    // Function to track the selected Field Labels.
    function updateSelectedFieldLabels() {
        const selectedLabels = new Set();
        document.querySelectorAll('.field-label-select').forEach(select => {
            if (select.value !== 'Select Field Label') {
                selectedLabels.add(select.value);
            }
        });
        return selectedLabels;
    }

    // Function to update the Field Label options based on selected Field Labels.
    function updateFieldLabelOptions(selectedLabels) {
        document.querySelectorAll('.field-label-select').forEach(select => {
            const currentValue = select.value;
            const options = select.querySelectorAll('option');

            options.forEach(option => {
                if (option.value !== 'Select Field Label' && option.value !== currentValue) {
                    option.style.display = selectedLabels.has(option.value) ? 'none' : ''; // Hide if selected, show otherwise
                }
            });
        });
    }

    function fieldLabelSelectChangeHandler() {
        // console.log("Field label select changed. Current fieldLabelSelect:", this); // Debugging
        const selectedProcedureID = document.getElementById('procedureSelect').value.trim();
        const selectedFormTab = document.getElementById('formTabSelect').value.trim();
        const selectedLabel = this.value;
        const compositeKey = `${selectedProcedureID}_${selectedFormTab}_${selectedLabel}`;
        const responseOptions = responseOptionsMap[compositeKey];

        // Log field labels and response options for debugging.
        //console.log("Selected label:", selectedLabel);
        //console.log("Response options for the selected label:", responseOptions);

        // Find the closest parent .field-label-group for the selected Field Label
        const parentContainer = this.closest('.field-label-group');
        if (!parentContainer) {
            console.error('Parent .field-label-group not found.');
            return;
        }

        // Find the .response-options-container within the parentContainer
        const responseOptionsContainer = parentContainer.querySelector('.response-options-container');
        if (!responseOptionsContainer) {
            console.error('Response options container not found within parent container.');
            return;
        }

        if (responseOptions && responseOptions.length > 0) {
            populateResponseOptions(this, selectedLabel, responseOptionsMap[compositeKey]);
        } else {
            // Clear the response options container if no response options are available for the selected label
            responseOptionsContainer.innerHTML = '';
            const statisticsSelector = createStatisticsSelect(true)
            responseOptionsContainer.appendChild(statisticsSelector);
            console.log("No response options for:", selectedLabel);
        }
    }

    function attachFieldLabelSelectListeners() {
        document.querySelectorAll('.field-label-select').forEach(select => {
            select.removeEventListener('change', fieldLabelSelectChangeHandler);
            select.addEventListener('change', fieldLabelSelectChangeHandler);
        });
    }

    function addResponseOptionSelector(container, option) {
        const selectorContainer = document.createElement('div');
        selectorContainer.className = 'response-option-selector';

        const select = document.createElement('select');
        select.className = 'form-select';

        const optionElement = document.createElement('option');
        optionElement.value = option.key;
        optionElement.textContent = option.value;
        select.appendChild(optionElement);

        const addButton = document.createElement('button');
        addButton.textContent = '+';
        addButton.onclick = () => addResponseOptionSelector(container, option);

        const removeButton = document.createElement('button');
        removeButton.textContent = '-';
        removeButton.onclick = () => selectorContainer.remove();

        selectorContainer.appendChild(select);
        selectorContainer.appendChild(addButton);
        selectorContainer.appendChild(removeButton);

        container.appendChild(selectorContainer);
    }

    function populateResponseOptions(fieldLabelSelect, fieldLabel) {
        const selectedProcedureID = document.getElementById('procedureSelect').value.trim();
        const selectedFormTab = document.getElementById('formTabSelect').value.trim();
        const compositeKey = `${selectedProcedureID}_${selectedFormTab}_${fieldLabel}`;

        // Ensure fieldLabelSelect is a DOM element

        if (!(fieldLabelSelect instanceof HTMLElement)) {
            console.error('fieldLabelSelect is not a valid DOM element.');
            return;
        }

        // console.log('Field Label Select Element:', fieldLabelSelect); //Debugging

        // Find the closest parent .field-label-group for the selected Field Label
        const parentContainer = fieldLabelSelect.closest('.field-label-group');
        // console.log('Parent Container:', parentContainer); //Debugging

        if (!parentContainer) {
            console.error('Parent .field-label-group not found.');
            return;
        }

        // Find the .response-options-container within the parentContainer
        const responseOptionsContainer = parentContainer.querySelector('.response-options-container');
        // console.log('Response Options Container:', responseOptionsContainer); //Debugging
        if (!responseOptionsContainer) {
            console.error('Response options container not found within parent container.', parentContainer);
            return;
        }

        // Clear any existing content in the response options container
        responseOptionsContainer.innerHTML = '';

        // Use the specific response options for the field label from responseOptionsMap
        const specificResponseOptions = responseOptionsMap[compositeKey] || [];

        // Sort and filter the response options
        if (specificResponseOptions.length === 0) {
            // If there are no response options, add a statistics select with the 'Input' option
            const statisticsSelect = createStatisticsSelect(true); // true indicates that the 'Input' option should be included
            responseOptionsContainer.appendChild(statisticsSelect);
        } else {
            specificResponseOptions
                .filter(option => /^\d+ = [^,]+(,|$)/.test(option.trim())) // Filter out options that don't match "# = text"
                .map(option => option.trim().split(' = ')) // Split the options into [number, text]
                .sort((a, b) => parseInt(a[0]) - parseInt(b[0])) // Sort based on the number
                .forEach(([number, text]) => {
                    const responseOptionGroup = createResponseOptionGroup(number + ' = ' + text, fieldLabel);
                    responseOptionsContainer.appendChild(responseOptionGroup);
                });
        }
        //console.log('Final Contents of Response Options Container:', responseOptionsContainer.innerHTML); //Debugging


        // Function to create a response option group
        function createResponseOptionGroup(option) {
            const responseOptionGroup = document.createElement('div');
            responseOptionGroup.className = 'response-option-group d-flex flex-row align-items-center mb-2 drag-drop';

            const removeButton = document.createElement('button');
            removeButton.className = 'btn btn-danger me-2';
            removeButton.textContent = '-';
            removeButton.onclick = () => {
                const optionValue = responseOptionSelect.value; // Value of the option being removed
                responseOptionGroup.remove(); // Remove the option group from the DOM

                if (responseOptionsMap[compositeKey]) {
                    // Add the removed option back to the list for its specific field label
                    responseOptionsMap[compositeKey].removed = responseOptionsMap[compositeKey].removed || [];
                    responseOptionsMap[compositeKey].removed.push(optionValue);
                }
                // Update the select elements to reflect the change
                updateResponseOptionSelectorsForLabel(fieldLabel);
            };

            const responseOptionSelect = document.createElement('select');
            responseOptionSelect.className = 'form-select response-option-select';
            responseOptionSelect.innerHTML = `<option value="${option}">${option}</option>`;

            const dragHandle = document.createElement('span');
            dragHandle.className = 'drag-handle btn btn-outline-secondary fa-solid fa-grip-lines';
            dragHandle.style.cursor = 'grab';

            const statisticsSelect = document.createElement('select');
            statisticsSelect.className = 'statistics-select form-select ms-2';
            const statsOptions = ['Percentage', 'Mean_SD', 'Count'];
            statsOptions.forEach(stat => {
                const optionElement = document.createElement('option');
                optionElement.value = stat.toLowerCase();
                optionElement.textContent = stat;
                statisticsSelect.appendChild(optionElement);
            });

            responseOptionGroup.appendChild(dragHandle);
            responseOptionGroup.appendChild(responseOptionSelect);
            responseOptionGroup.appendChild(statisticsSelect);
            responseOptionGroup.appendChild(removeButton);

            return responseOptionGroup;
        }
    }

    function createStatisticsSelect(includeInput = false) {
        const statisticsSelect = document.createElement('select');
        statisticsSelect.className = 'statistics-select form-select ms-2';
        const statsOptions = ['Percentage', 'Mean_SD', 'Count'];
        if (includeInput) {
            statsOptions.push('Input'); // Include 'Input' if no response options
        }
        statsOptions.forEach(stat => {
            const optionElement = document.createElement('option');
            optionElement.value = stat.toLowerCase();
            optionElement.textContent = stat;
            statisticsSelect.appendChild(optionElement);
        });

        statisticsSelect.addEventListener('change', function () {
            const nextSibling = this.nextElementSibling;
            if (this.value === 'input') {
                // Add input box if it does not exist
                if (!nextSibling || nextSibling.nodeName !== 'INPUT') {
                    const inputBox = document.createElement('input');
                    inputBox.type = 'text';
                    inputBox.className = 'input-select form-control ms-2';
                    this.parentNode.insertBefore(inputBox, this.nextSibling);
                }
            } else {
                // Remove input box if it exists
                if (nextSibling && nextSibling.nodeName === 'INPUT') {
                    nextSibling.remove();
                }
            }
        });

        return statisticsSelect;
    }

    function updateResponseOptionSelectorsForLabel(fieldLabel) {
        // Find all select elements within the response options container for the specific field label
        const selectedProcedureID = document.getElementById('procedureSelect').value.trim();
        const selectedFormTab = document.getElementById('formTabSelect').value.trim();
        const compositeKey = `${selectedProcedureID}_${selectedFormTab}_${fieldLabel}`;

        const containers = document.querySelectorAll(`.response-options-container[data-field-label="${fieldLabel}"]`);

        containers.forEach(container => {
            const selects = container.querySelectorAll('.response-option-select');

            selects.forEach(select => {
                const currentSelectedValue = select.value;
                const optionsToInclude = new Set(responseOptionsMap[compositeKey]);

                // Clear the select element
                select.innerHTML = '';

                // Add the currently selected option and any removed options to the select element
                optionsToInclude.forEach(optionValue => {
                    const optionEl = document.createElement('option');
                    optionEl.value = optionValue;
                    optionEl.textContent = optionValue;
                    // Set the current selected value as selected
                    if (optionValue === currentSelectedValue) {
                        optionEl.selected = true;
                    }
                    select.appendChild(optionEl);
                });
            });
        });
    }


    function populateInitialResponseOptions() {
        const selectedProcedureID = document.getElementById('procedureSelect').value.trim();
        const selectedFormTab = document.getElementById('formTabSelect').value.trim();
        const initialFieldLabelSelect = document.getElementById('fieldLabelSelect');
        const initialFieldLabel = initialFieldLabelSelect.value;
        const compositeKey = `${selectedProcedureID}_${selectedFormTab}_${initialFieldLabel}`;
        const responseOptions = responseOptionsMap[compositeKey];

        if (responseOptions) {
            const initialResponseOptionsContainer = document.getElementById('initial-field-label-group').querySelector('.response-options-container');
            if (initialResponseOptionsContainer) {
                initialResponseOptionsContainer.innerHTML = '';
                responseOptions.forEach(option => {
                    const optionElement = document.createElement('div');
                    optionElement.textContent = option.trim();
                    initialResponseOptionsContainer.appendChild(optionElement);
                });
            } else {
                console.error('Initial response options container not found.');
            }
        } else if (initialFieldLabelSelect.value !== 'Select Field Label') {
            console.error('No response options found for initial field label.');
        }
    }


    function updateResponseOptionSelectors(fieldLabel) {
        const selectedProcedureID = document.getElementById('procedureSelect').value.trim();
        const selectedFormTab = document.getElementById('formTabSelect').value.trim();
        const compositeKey = `${selectedProcedureID}_${selectedFormTab}_${fieldLabel}`;
        // Find all selectors for the specific Field Label
        const selectors = document.querySelectorAll(`.field-label-select[value="${fieldLabel}"] + .response-options-container .response-option-select`);

        selectors.forEach(select => {
            const currentSelectedValue = select.value;
            select.innerHTML = ''; // Clear current options

            responseOptionsMap[compositeKey].forEach(optionValue => {
                const optionElement = document.createElement('option');
                optionElement.value = optionValue;
                optionElement.textContent = optionValue;
                if (optionValue === currentSelectedValue) {
                    optionElement.selected = true;
                }
                select.appendChild(optionElement);
            });
        });
    }

    document.getElementById('addHeaderToTableBtn').addEventListener('click', function () {
        const headerValue = document.getElementById('headerInput').value;
        const deviceValue = document.getElementById('deviceInput').value;

        // Function to find first entirely blank row
        function findFirstEmptyRow(hotInstance) {
            let rowCount = hotInstance.countRows();
            for (let i = 0; i < rowCount; i++) {
                let row = hotInstance.getDataAtRow(i);
                if (row.every(cell => !cell || cell === '')) {
                    return i;
                }
            }
            return rowCount; // If no empty row, return index after the last row
        }

        let firstEmptyRowIndex = findFirstEmptyRow(hotTableViewer);

        // Set the header in the first column
        hotTableViewer.setDataAtCell(firstEmptyRowIndex, 0, headerValue);
        // Set the device in the third column
        hotTableViewer.setDataAtCell(firstEmptyRowIndex, 2, deviceValue);
    });

    document.getElementById('addSubheaderToTableBtn').addEventListener('click', function () {
        const subheaderValue = document.getElementById('subheaderInput').value;
        const selectedStatistic = document.getElementById('subHeaderStatisticsSelect').value;

        // Function to find first entirely blank row
        function findFirstEmptyRow(hotInstance) {
            let rowCount = hotInstance.countRows();
            for (let i = 0; i < rowCount; i++) {
                let row = hotInstance.getDataAtRow(i);
                if (row.every(cell => !cell || cell === '')) {
                    return i;
                }
            }
            return rowCount; // If no empty row, return index after the last row
        }

        let firstEmptyRowIndex = findFirstEmptyRow(hotTableViewer);

        // Parse the selected statistic into the desired format
        let statisticText = '';
        switch (selectedStatistic.toLowerCase()) {
            case 'count':
                statisticText = "XX"; // Placeholder - replace with actual count value
                break;
            case 'mean_sd':
                statisticText = "XX.x ± X.x"; // Placeholder - replace with actual mean value
                break;
            case 'percentage':
                statisticText = "XX.x% (m/n)"; // Placeholder - replace with actual percentage value
                break;
        }

        // Set the subheader in the second column
        hotTableViewer.setDataAtCell(firstEmptyRowIndex, 0, subheaderValue);
        // Set the statistic in the third column
        hotTableViewer.setDataAtCell(firstEmptyRowIndex, 2, statisticText);
    });


    document.getElementById('addToTableBtn').addEventListener('click', function () {
        // Function to find the first entirely blank row
        function findFirstEmptyRow(hotInstance) {
            let rowCount = hotInstance.countRows();
            for (let i = 0; i < rowCount; i++) {
                let row = hotInstance.getDataAtRow(i);
                if (row.every(cell => !cell || cell === '')) {
                    return i;
                }
            }
            return rowCount; // If no empty row, return index after the last row
        }

        let firstEmptyRowIndex = findFirstEmptyRow(hotTableViewer);
        const fieldLabelSelects = document.querySelectorAll('.field-label-select');

        fieldLabelSelects.forEach((select) => {
            const fieldLabel = select.value;
            const fieldCode = select.selectedOptions[0].getAttribute('data-field-code');
            const parentContainer = select.closest('.field-label-group');
            const responseOptionsContainer = parentContainer.querySelector('.response-options-container');
            const responseOptionGroups = responseOptionsContainer.querySelectorAll('.response-option-group');
            const statisticsSelect = parentContainer.querySelector('.statistics-select');
            let fieldLabelAdded = false; // Flag to add the field label only once

            if (responseOptionGroups.length === 0 && statisticsSelect && statisticsSelect.value === 'input') {
                // Handle the case where 'input' is selected and there are no response options
                const inputBox = parentContainer.querySelector('.input-select');
                let inputText = inputBox ? inputBox.value : '';
                if (!fieldLabelAdded) {
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 0, fieldLabel);
                    fieldLabelAdded = true;
                }
                hotTableViewer.setDataAtCell(firstEmptyRowIndex, 2, inputText);
                firstEmptyRowIndex++;
            } else if (responseOptionGroups.length === 0 && statisticsSelect) {
                let statistic = statisticsSelect ? statisticsSelect.value.toLowerCase() : '';
                let statisticDisplayText = statisticsSelect.options[statisticsSelect.selectedIndex].text;
                let statisticText = '';

                // Parse the statistic option
                switch (statistic) {
                    case 'count':
                        statisticText = "XX"; // Placeholder for actual count value
                        break;
                    case 'mean_sd':
                        statisticText = "XX.x ± X.x"; // Placeholder for actual mean value
                        break;
                    case 'percentage':
                        statisticText = "XX.x% (m/n)"; // Placeholder for actual percentage value
                        break;
                    case 'input':
                        const inputBox = parentContainer.querySelector('.input-select');
                        statisticText = inputBox ? inputBox.value : '';
                        break;
                    default:
                        statisticText = statistic; // Use the provided text if no match
                }

                if (!fieldLabelAdded) {
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 0, fieldLabel);
                    fieldLabelAdded = true;
                }
                hotTableViewer.setDataAtCell(firstEmptyRowIndex, 2, statisticText);
                hotTableViewer.setDataAtCell(firstEmptyRowIndex, 3, statisticDisplayText);
                hotTableViewer.setDataAtCell(firstEmptyRowIndex, 4, fieldCode);
                firstEmptyRowIndex++;
            } else {
                // Handle normal response options
                responseOptionGroups.forEach((group) => {
                    const responseOptionSelect = group.querySelector('.response-option-select');
                    let responseOptionText = responseOptionSelect ? responseOptionSelect.value.match(/\d+\s*=\s*(.+)/)[1] : '';
                    const statisticsSelect = group.querySelector('.statistics-select');
                    let statisticDisplayText = statisticsSelect.options[statisticsSelect.selectedIndex].text;
                    let statistic = statisticsSelect ? statisticsSelect.value.toLowerCase() : '';
                    let statisticText = '';

                    // Parse the statistic option
                    switch (statistic) {
                        case 'count':
                            statisticText = "XX"; // Placeholder for actual count value
                            break;
                        case 'mean_sd':
                            statisticText = "XX.x ± X.x"; // Placeholder for actual mean value
                            break;
                        case 'percentage':
                            statisticText = "XX.x% (m/n)"; // Placeholder for actual percentage value
                            break;
                        default:
                            statisticText = statistic; // Use the provided text if no match
                    }

                    // Add the field label only on the first applicable row
                    if (!fieldLabelAdded) {
                        hotTableViewer.setDataAtCell(firstEmptyRowIndex, 0, fieldLabel);
                        fieldLabelAdded = true;
                    }

                    // Add response option, statistic, and generated R columns
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 1, responseOptionText);
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 2, statisticText);
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 3, statisticDisplayText);
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 4, fieldCode);
                    hotTableViewer.setDataAtCell(firstEmptyRowIndex, 5, responseOptionSelect.value.match(/^\d+/)[0])

                    firstEmptyRowIndex++; // Move to the next row for the next iteration
                });
            }
        });

        const hideColumns = hotTableViewer.getPlugin('hiddenColumns')
        hideColumns.hideColumn(3, 4, 5);
        hotTableViewer.render();
    });


    function loadData() {
        const excelFile = document.getElementById('excelFile').files[0];
        const sheetName = document.getElementById('sheetName').value;
        sessionStorage.setItem('sheetName', sheetName)

        const formData = new FormData();
        formData.append('excel_file', excelFile);
        formData.append('sheet_name', sheetName);

        fetch('/get_data', {
            method: 'POST',
            body: formData,
        })
            .then(response => response.json())
            .then(response => {
                //console.log(response); //Debugging
                if (response.data && response.data.length > 0) {
                    const container = document.getElementById('hot');

                    const columnOrder = response.columns; // Use the received column order

                    const hotColumns = columnOrder.map(col => ({
                        data: col
                    }));

                    hotDataDictionary = new Handsontable(container, {
                        licenseKey: 'non-commercial-and-evaluation',
                        data: response.data,
                        rowHeaders: true,
                        colHeaders: columnOrder,
                        columns: hotColumns,
                        filters: true,
                        dropdownMenu: true,
                        manualColumnMove: true,
                        contextMenu: true,
                        colWidths: 150
                    });

                    // Check if the imported data dictionary is empty
                    if (hotDataDictionary.countRows() === 0) {
                        alert('The table is empty.');
                        hotDataDictionary.destroy();
                        hotDataDictionary = null;
                        return;
                    }

                    // Validate the column headers. If invalid, delete the HoT instance and exit the function
                    if (!validateColumns(hotDataDictionary)) {
                        // Delete HoT instance
                        hotDataDictionary.destroy();
                        hotDataDictionary = null;
                        return; // Exit the function
                    }

                    //Log to check if hotDataDictionary is initialized correctly
                    //console.log('Hot instance after creation:', hotDataDictionary); // Debugging
                    populateProcedureSelect()

                } else {
                    alert("Sheet '" + sheetName + "' not found in the Excel file.");
                }
            })
            .catch(error => {
                alert(error.message)
            });
    }

    function validateColumns(hotInstance) {
        const columnHeaders = hotInstance.getColHeader();
        const requiredColumns = ['PROCEDUREID', 'FORM_TAB', 'FIELD_LABEL', 'FIELD_CODE', 'FIELD_STATUS', 'RESPONSE_OPTIONS'];
        const missingColumns = requiredColumns.filter(col => !columnHeaders.includes(col));

        if (missingColumns.length > 0) {
            alert(`Missing required columns: ${missingColumns.join(', ')}`);
            return false;
        } else {
            return true;
        }
    }


    function exportToExcel(hotTable) {
        if (!hotTable) {
            alert('No Handsontable instance found.');
            return;
        }

        const data = hotTable.getData();
        if (data.length === 0 || data.every(row => row.every(cell => cell === null || cell === ''))) {
            alert('No data found in the table.');
            return;
        }
        // alert('Data fetched: ' + JSON.stringify(data)); //Debugging

        const headers = ['Col1', 'Col2', 'Col3', 'Aggregate_Function', 'Data_Field', 'Numerator_Value']

        // Convert data for xlsx
        const wsData = [headers, ...data];
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        const wb = XLSX.utils.book_new();

        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

        // Create blob, generate download link and click it programmatically
        const wbout = XLSX.write(wb, {bookType: 'xlsx', type: 'binary'});
        const blob = new Blob([s2ab(wbout)], {type: 'application/octet-stream'});
        const blobURL = window.URL.createObjectURL(blob);

        const date = new Date().toJSON().slice(0,10).replace(/-/g,'_');
        const dateString = "exported_data_" + date + ".xlsx";


        const tempLink = document.createElement('a');
        tempLink.href = blobURL;
        tempLink.setAttribute('download', dateString);
        tempLink.click();

        function s2ab(s) {
            const buf = new ArrayBuffer(s.length);
            const view = new Uint8Array(buf);
            for (let i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xFF;
            return buf;
        }
    }

    var myModal = new bootstrap.Modal(document.getElementById('myModal'), {
        keyboard: false
    });
</script>
</body>
</html>
